# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details


import json
import os
import sys
from io import TextIOWrapper
from typing import Optional

import click
import obstore
import pydantic
import ruamel.yaml

from .dispatch import dispatch
from .formdata import FormData
from .metadata import (
    formdata_to_params,
    get_data_connection_property_names,
    get_rjsf,
    params_to_formdata,
)
from .params import Params


@click.group()
def cli() -> None:
    pass


@cli.command()
@click.option(
    "--config-file",
    type=click.File("r"),
    required=False,
    help="Configuration parameters for running the workflow.",
)
@click.option(
    "--config-json",
    type=str,
    required=False,
    help="JSON string of configuration parameters for running the workflow.",
)
@click.option(
    "--execution-mode",
    required=True,
    type=click.Choice(["async", "sequential"]),
)
@click.option(
    "--mock-io/--no-mock-io",
    is_flag=True,
    default=False,
    help="Whether or not to mock io with 3rd party services; for testing only.",
)
def run(
    config_file: Optional[TextIOWrapper],
    config_json: Optional[str],
    execution_mode: str,
    mock_io: bool,
) -> None:
    # Validate that exactly one of --config-file or --config-json is provided
    if (config_file is not None and config_json is not None) or (
        config_file is None and config_json is None
    ):
        raise click.UsageError(
            "Exactly one of --config-file or --config-json must be provided."
        )

    # Load configuration based on which option is provided
    if config_file is not None:
        yaml = ruamel.yaml.YAML(typ="safe")
        params = Params(**yaml.load(config_file))
    else:  # config_json is not None
        try:
            config_dict = json.loads(config_json)
            params = Params(**config_dict)
        except json.JSONDecodeError as e:
            raise click.BadParameter(
                "Invalid JSON string for --config-json", param_hint="--config-json"
            ) from e
        except pydantic.ValidationError as e:
            raise click.BadParameter(
                f"Invalid configuration: {e}", param_hint="--config-json"
            ) from e

    # Rest of the function remains unchanged
    results_url = os.environ.get("ECOSCOPE_WORKFLOWS_RESULTS")
    if not results_url:
        raise ValueError("Environment variable ECOSCOPE_WORKFLOWS_RESULTS is required.")
    response = dispatch(execution_mode, mock_io, params)
    result_store = obstore.store.from_url(results_url)
    result_bytes = response.model_dump_json().encode("utf-8")
    put_result = result_store.put("result.json", result_bytes)
    if not put_result:
        raise RuntimeError("Failed to put result json in result store.")


@cli.command()
@click.argument(
    "metadata_attribute",
    type=click.Choice(["rjsf", "data-connection-property-names"]),
    required=True,
)
def get(metadata_attribute: str) -> None:
    """Get the metadata for the workflow."""
    getter = {
        "rjsf": get_rjsf,
        "data-connection-property-names": get_data_connection_property_names,
    }.get(metadata_attribute)
    if getter is None:
        raise ValueError(f"Unknown metadata attribute: {metadata_attribute}")
    result = getter()
    as_json = json.dumps(result)
    print(as_json)


@cli.command()
@click.option(
    "--from",
    "from_",
    required=True,
    type=click.Choice(["params", "formdata"]),
)
@click.option(
    "--to",
    required=True,
    type=click.Choice(["params", "formdata"]),
)
@click.option(
    "--json",
    "json_",
    required=True,
    type=click.File("r"),
    default=sys.stdin,
)
def convert(
    from_: str,
    to: str,
    json_: TextIOWrapper,
) -> None:
    """Get the metadata for the workflow."""
    json_txt = json_.read()
    try:
        loaded = json.loads(json_txt)
    except json.JSONDecodeError as e:
        raise ValueError(f"Failed to parse JSON string: {json_txt}") from e
    try:
        match from_, to:
            case ("params", "formdata"):
                result = params_to_formdata(loaded)
                as_json = json.dumps(result)
            case ("formdata", "params"):
                formdata = FormData(**loaded)
                result = formdata_to_params(formdata)
                as_json = result.model_dump_json()
            case _:
                raise ValueError(f"Unknown conversion: {from_} -> {to}")
    except pydantic.ValidationError as e:
        as_json = e.json(include_url=True)

    print(as_json)


if __name__ == "__main__":
    cli()
