# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details
import json
import os

from ecoscope_workflows_core.graph import DependsOn, Graph, Node
from ecoscope_workflows_core.tasks.config import set_string_var as set_string_var
from ecoscope_workflows_core.tasks.config import (
    set_workflow_details as set_workflow_details,
)
from ecoscope_workflows_core.tasks.filter import set_time_range as set_time_range
from ecoscope_workflows_core.tasks.io import persist_text as persist_text
from ecoscope_workflows_core.tasks.io import set_er_connection as set_er_connection
from ecoscope_workflows_core.tasks.io import set_gee_connection as set_gee_connection
from ecoscope_workflows_core.tasks.results import gather_dashboard as gather_dashboard
from ecoscope_workflows_core.tasks.skip import (
    any_dependency_skipped as any_dependency_skipped,
)
from ecoscope_workflows_core.tasks.skip import any_is_empty_df as any_is_empty_df
from ecoscope_workflows_core.tasks.transformation import (
    add_temporal_index as add_temporal_index,
)
from ecoscope_workflows_core.tasks.transformation import sort_values as sort_values
from ecoscope_workflows_ext_custom.tasks.io import html_to_png as html_to_png
from ecoscope_workflows_ext_custom.tasks.io import load_df as load_df
from ecoscope_workflows_ext_custom.tasks.results import (
    create_path_layer as create_path_layer,
)
from ecoscope_workflows_ext_custom.tasks.results import (
    create_scatterplot_layer as create_scatterplot_layer,
)
from ecoscope_workflows_ext_custom.tasks.results import draw_map as draw_map
from ecoscope_workflows_ext_custom.tasks.results import (
    set_base_maps_pydeck as set_base_maps_pydeck,
)
from ecoscope_workflows_ext_custom.tasks.transformation import (
    drop_null_geometry as drop_null_geometry,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import get_events as get_events
from ecoscope_workflows_ext_ecoscope.tasks.io import (
    get_patrol_observations as get_patrol_observations,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import (
    get_subjectgroup_observations as get_subjectgroup_observations,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import persist_df as persist_df
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import (
    process_relocations as process_relocations,
)
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import (
    relocations_to_trajectory as relocations_to_trajectory,
)
from ecoscope_workflows_ext_ecoscope.tasks.transformation import (
    apply_classification as apply_classification,
)
from ecoscope_workflows_ext_ecoscope.tasks.transformation import (
    apply_color_map as apply_color_map,
)
from ecoscope_workflows_ext_mep.tasks import compile_sitrep as compile_sitrep
from ecoscope_workflows_ext_mep.tasks import get_previous_period as get_previous_period
from ecoscope_workflows_ext_mep.tasks import (
    get_sitrep_event_config as get_sitrep_event_config,
)
from ecoscope_workflows_ext_mep.tasks import (
    process_aoi_ndvi_charts as process_aoi_ndvi_charts,
)
from ecoscope_workflows_ext_mep.tasks import (
    process_collar_voltage_charts as process_collar_voltage_charts,
)
from ecoscope_workflows_ext_mnc.tasks import (
    exclude_geom_outliers as exclude_geom_outliers,
)
from ecoscope_workflows_ext_ste.tasks import (
    fetch_and_persist_file as fetch_and_persist_file,
)
from ecoscope_workflows_ext_ste.tasks import filter_df_cols as filter_df_cols
from ecoscope_workflows_ext_ste.tasks import set_custom_groupers as set_custom_groupers
from ecoscope_workflows_ext_ste.tasks import transform_gdf_crs as transform_gdf_crs
from ecoscope_workflows_ext_ste.tasks import view_state_deck_gdf as view_state_deck_gdf

from ..params import Params


def main(params: Params):
    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    dependencies = {
        "workflow_details": [],
        "time_range": [],
        "groupers": [],
        "configure_base_maps": [],
        "er_client_name": [],
        "gee_project_name": [],
        "get_events_data": ["er_client_name", "time_range"],
        "exclude_mep_outliers": ["get_events_data"],
        "remove_mep_invalid_geoms": ["exclude_mep_outliers"],
        "generate_mb_layers": ["remove_mep_invalid_geoms"],
        "sighting_zoom_value": ["remove_mep_invalid_geoms"],
        "draw_sightings_map": [
            "configure_base_maps",
            "generate_mb_layers",
            "sighting_zoom_value",
        ],
        "persist_sightings_urls": ["draw_sightings_map"],
        "subject_group_var": [],
        "subject_observations": ["er_client_name", "time_range", "subject_group_var"],
        "subject_reloc": ["subject_observations"],
        "get_custom_previous_period": ["time_range"],
        "previous_subject_observations": [
            "er_client_name",
            "get_custom_previous_period",
            "subject_group_var",
        ],
        "previous_subject_reloc": ["previous_subject_observations"],
        "process_subject_charts": [
            "subject_observations",
            "previous_subject_observations",
            "time_range",
        ],
        "convert_to_trajectories": ["subject_reloc"],
        "add_temporal_index_to_traj": ["convert_to_trajectories", "groupers"],
        "classify_trajectories_speed_bins": ["add_temporal_index_to_traj"],
        "sort_trajs_by_speed": ["classify_trajectories_speed_bins"],
        "apply_speed_colormap": ["sort_trajs_by_speed"],
        "filter_speed_cols": ["apply_speed_colormap"],
        "generate_speedmap_layers": ["filter_speed_cols"],
        "zoom_speed_gdf_extent": ["filter_speed_cols"],
        "draw_speedmap": [
            "configure_base_maps",
            "generate_speedmap_layers",
            "zoom_speed_gdf_extent",
        ],
        "persist_speedmap_html": ["draw_speedmap"],
        "get_sitrep_config": [],
        "generate_sitrep_df": ["er_client_name", "get_sitrep_config", "time_range"],
        "persist_livestock_events_gpkg": ["generate_sitrep_df"],
        "vehicle_patrols": ["er_client_name", "time_range"],
        "vehicle_patrol_reloc": ["vehicle_patrols"],
        "vehicle_patrol_traj": ["vehicle_patrol_reloc"],
        "persist_vehicle_traj": ["vehicle_patrol_traj"],
        "vehicle_traj_colormap": ["vehicle_patrol_traj"],
        "vehicle_zoom_value": ["vehicle_traj_colormap"],
        "vehicle_patrol_path_layer": ["vehicle_traj_colormap"],
        "draw_vehicles_map": [
            "configure_base_maps",
            "vehicle_patrol_path_layer",
            "vehicle_zoom_value",
        ],
        "vehicle_patrol_map": ["draw_vehicles_map"],
        "foot_patrols": ["er_client_name", "time_range"],
        "foot_patrol_reloc": ["foot_patrols"],
        "foot_patrol_traj": ["foot_patrol_reloc"],
        "persist_foot_traj": ["foot_patrol_traj"],
        "foot_traj_colormap": ["foot_patrol_traj"],
        "foot_zoom_value": ["foot_traj_colormap"],
        "foot_patrol_path_layer": ["foot_traj_colormap"],
        "draw_foot_map": [
            "configure_base_maps",
            "foot_patrol_path_layer",
            "foot_zoom_value",
        ],
        "foot_patrol_map": ["draw_foot_map"],
        "download_roi_file": [],
        "load_roi": ["download_roi_file"],
        "transform_roi": ["load_roi"],
        "process_ndvi_charts": ["transform_roi", "gee_project_name", "time_range"],
        "convert_sightings_png": ["persist_sightings_urls"],
        "convert_speedmap_png": ["persist_speedmap_html"],
        "convert_vehicle_png": ["vehicle_patrol_map"],
        "convert_foot_png": ["foot_patrol_map"],
        "convert_ndvi_png": ["process_ndvi_charts"],
        "convert_collared_png": ["process_subject_charts"],
        "mep_monthly_dashboard": ["workflow_details", "time_range", "groupers"],
    }

    nodes = {
        "workflow_details": Node(
            async_task=set_workflow_details.validate()
            .set_task_instance_id("workflow_details")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("workflow_details") or {}),
            method="call",
        ),
        "time_range": Node(
            async_task=set_time_range.validate()
            .set_task_instance_id("time_range")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("time_range") or {}),
            method="call",
        ),
        "groupers": Node(
            async_task=set_custom_groupers.validate()
            .set_task_instance_id("groupers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={} | (params_dict.get("groupers") or {}),
            method="call",
        ),
        "configure_base_maps": Node(
            async_task=set_base_maps_pydeck.validate()
            .set_task_instance_id("configure_base_maps")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("configure_base_maps") or {}),
            method="call",
        ),
        "er_client_name": Node(
            async_task=set_er_connection.validate()
            .set_task_instance_id("er_client_name")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("er_client_name") or {}),
            method="call",
        ),
        "gee_project_name": Node(
            async_task=set_gee_connection.validate()
            .set_task_instance_id("gee_project_name")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("gee_project_name") or {}),
            method="call",
        ),
        "get_events_data": Node(
            async_task=get_events.validate()
            .set_task_instance_id("get_events_data")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "client": DependsOn("er_client_name"),
                "time_range": DependsOn("time_range"),
                "event_columns": [
                    "id",
                    "time",
                    "event_type",
                    "event_category",
                    "reported_by",
                    "serial_number",
                    "geometry",
                    "created_at",
                    "event_details",
                ],
                "event_types": [
                    "mep_elephant_sighting",
                ],
                "raise_on_empty": True,
                "include_details": True,
                "include_updates": False,
                "include_related_events": False,
                "include_null_geometry": False,
                "include_display_values": False,
            }
            | (params_dict.get("get_events_data") or {}),
            method="call",
        ),
        "exclude_mep_outliers": Node(
            async_task=exclude_geom_outliers.validate()
            .set_task_instance_id("exclude_mep_outliers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("get_events_data"),
                "z_threshold": 3,
            }
            | (params_dict.get("exclude_mep_outliers") or {}),
            method="call",
        ),
        "remove_mep_invalid_geoms": Node(
            async_task=drop_null_geometry.validate()
            .set_task_instance_id("remove_mep_invalid_geoms")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("exclude_mep_outliers"),
                "geometry_column": "geometry",
            }
            | (params_dict.get("remove_mep_invalid_geoms") or {}),
            method="call",
        ),
        "generate_mb_layers": Node(
            async_task=create_scatterplot_layer.validate()
            .set_task_instance_id("generate_mb_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "get_fill_color": [
                        85,
                        107,
                        47,
                    ],
                    "get_line_color": [
                        0,
                        0,
                        0,
                        200,
                    ],
                    "get_line_width": 0.55,
                    "get_radius": 5,
                    "opacity": 0.75,
                    "stroked": True,
                },
                "legend": {
                    "title": "Legend",
                    "values": [
                        {
                            "label": "Elephant sightings",
                            "color": "#556b2f",
                        },
                    ],
                },
                "geodataframe": DependsOn("remove_mep_invalid_geoms"),
            }
            | (params_dict.get("generate_mb_layers") or {}),
            method="call",
        ),
        "sighting_zoom_value": Node(
            async_task=view_state_deck_gdf.validate()
            .set_task_instance_id("sighting_zoom_value")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "pitch": 0,
                "bearing": 0,
                "gdf": DependsOn("remove_mep_invalid_geoms"),
            }
            | (params_dict.get("sighting_zoom_value") or {}),
            method="call",
        ),
        "draw_sightings_map": Node(
            async_task=draw_map.validate()
            .set_task_instance_id("draw_sightings_map")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "static": False,
                "title": None,
                "max_zoom": 10,
                "legend_style": {
                    "placement": "bottom-right",
                },
                "geo_layers": DependsOn("generate_mb_layers"),
                "view_state": DependsOn("sighting_zoom_value"),
            }
            | (params_dict.get("draw_sightings_map") or {}),
            method="call",
        ),
        "persist_sightings_urls": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("persist_sightings_urls")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "text": DependsOn("draw_sightings_map"),
                "filename": "elephant_sightings_map.html",
            }
            | (params_dict.get("persist_sightings_urls") or {}),
            method="call",
        ),
        "subject_group_var": Node(
            async_task=set_string_var.validate()
            .set_task_instance_id("subject_group_var")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("subject_group_var") or {}),
            method="call",
        ),
        "subject_observations": Node(
            async_task=get_subjectgroup_observations.validate()
            .set_task_instance_id("subject_observations")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "client": DependsOn("er_client_name"),
                "time_range": DependsOn("time_range"),
                "subject_group_name": DependsOn("subject_group_var"),
                "raise_on_empty": False,
                "include_details": True,
                "include_subjectsource_details": True,
            }
            | (params_dict.get("subject_observations") or {}),
            method="call",
        ),
        "subject_reloc": Node(
            async_task=process_relocations.validate()
            .set_task_instance_id("subject_reloc")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "observations": DependsOn("subject_observations"),
                "relocs_columns": [
                    "groupby_col",
                    "fixtime",
                    "junk_status",
                    "geometry",
                    "extra__subject__name",
                    "extra__subject__hex",
                    "extra__subject__sex",
                    "extra__created_at",
                    "extra__subject__subject_subtype",
                    "extra__subjectsource__id",
                    "extra__subjectsource__assigned_range",
                    "extra__observation_details",
                ],
                "filter_point_coords": [
                    {
                        "x": 180.0,
                        "y": 90.0,
                    },
                    {
                        "x": 0.0,
                        "y": 0.0,
                    },
                    {
                        "x": 1.0,
                        "y": 1.0,
                    },
                ],
            }
            | (params_dict.get("subject_reloc") or {}),
            method="call",
        ),
        "get_custom_previous_period": Node(
            async_task=get_previous_period.validate()
            .set_task_instance_id("get_custom_previous_period")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "time_range": DependsOn("time_range"),
            }
            | (params_dict.get("get_custom_previous_period") or {}),
            method="call",
        ),
        "previous_subject_observations": Node(
            async_task=get_subjectgroup_observations.validate()
            .set_task_instance_id("previous_subject_observations")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "client": DependsOn("er_client_name"),
                "time_range": DependsOn("get_custom_previous_period"),
                "subject_group_name": DependsOn("subject_group_var"),
                "raise_on_empty": False,
                "include_details": True,
                "include_subjectsource_details": True,
            }
            | (params_dict.get("previous_subject_observations") or {}),
            method="call",
        ),
        "previous_subject_reloc": Node(
            async_task=process_relocations.validate()
            .set_task_instance_id("previous_subject_reloc")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "observations": DependsOn("previous_subject_observations"),
                "relocs_columns": [
                    "groupby_col",
                    "fixtime",
                    "junk_status",
                    "geometry",
                    "extra__subject__name",
                    "extra__subject__hex",
                    "extra__subject__sex",
                    "extra__created_at",
                    "extra__subject__subject_subtype",
                    "extra__subjectsource__id",
                    "extra__subjectsource__assigned_range",
                    "extra__observation_details",
                ],
                "filter_point_coords": [
                    {
                        "x": 180.0,
                        "y": 90.0,
                    },
                    {
                        "x": 0.0,
                        "y": 0.0,
                    },
                    {
                        "x": 1.0,
                        "y": 1.0,
                    },
                ],
            }
            | (params_dict.get("previous_subject_reloc") or {}),
            method="call",
        ),
        "process_subject_charts": Node(
            async_task=process_collar_voltage_charts.validate()
            .set_task_instance_id("process_subject_charts")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "relocs": DependsOn("subject_observations"),
                "previous_relocs": DependsOn("previous_subject_observations"),
                "time_range": DependsOn("time_range"),
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("process_subject_charts") or {}),
            method="call",
        ),
        "convert_to_trajectories": Node(
            async_task=relocations_to_trajectory.validate()
            .set_task_instance_id("convert_to_trajectories")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "relocations": DependsOn("subject_reloc"),
                "trajectory_segment_filter": {
                    "min_length_meters": 0.001,
                    "max_length_meters": 5000,
                    "min_time_secs": 1,
                    "max_time_secs": 21600,
                    "min_speed_kmhr": 0.01,
                    "max_speed_kmhr": 9,
                },
            }
            | (params_dict.get("convert_to_trajectories") or {}),
            method="call",
        ),
        "add_temporal_index_to_traj": Node(
            async_task=add_temporal_index.validate()
            .set_task_instance_id("add_temporal_index_to_traj")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("convert_to_trajectories"),
                "time_col": "segment_start",
                "groupers": DependsOn("groupers"),
                "cast_to_datetime": True,
                "format": "mixed",
            }
            | (params_dict.get("add_temporal_index_to_traj") or {}),
            method="call",
        ),
        "classify_trajectories_speed_bins": Node(
            async_task=apply_classification.validate()
            .set_task_instance_id("classify_trajectories_speed_bins")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("add_temporal_index_to_traj"),
                "input_column_name": "speed_kmhr",
                "output_column_name": "speed_bins",
                "classification_options": {
                    "scheme": "equal_interval",
                    "k": 6,
                },
                "label_options": {
                    "label_ranges": True,
                    "label_decimals": 1,
                    "label_suffix": " km/h",
                },
            }
            | (params_dict.get("classify_trajectories_speed_bins") or {}),
            method="call",
        ),
        "sort_trajs_by_speed": Node(
            async_task=sort_values.validate()
            .set_task_instance_id("sort_trajs_by_speed")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "column_name": "speed_bins",
                "na_position": "first",
                "ascending": True,
                "df": DependsOn("classify_trajectories_speed_bins"),
            }
            | (params_dict.get("sort_trajs_by_speed") or {}),
            method="call",
        ),
        "apply_speed_colormap": Node(
            async_task=apply_color_map.validate()
            .set_task_instance_id("apply_speed_colormap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "input_column_name": "speed_bins",
                "output_column_name": "speed_bins_colormap",
                "colormap": [
                    "#1a9850",
                    "#91cf60",
                    "#d9ef8b",
                    "#fee08b",
                    "#fc8d59",
                    "#d73027",
                ],
                "df": DependsOn("sort_trajs_by_speed"),
            }
            | (params_dict.get("apply_speed_colormap") or {}),
            method="call",
        ),
        "filter_speed_cols": Node(
            async_task=filter_df_cols.validate()
            .set_task_instance_id("filter_speed_cols")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "columns": [
                    "dist_meters",
                    "speed_bins_colormap",
                    "geometry",
                    "speed_kmhr",
                    "speed_bins",
                ],
                "df": DependsOn("apply_speed_colormap"),
            }
            | (params_dict.get("filter_speed_cols") or {}),
            method="call",
        ),
        "generate_speedmap_layers": Node(
            async_task=create_path_layer.validate()
            .set_task_instance_id("generate_speedmap_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "get_color": "speed_bins_colormap",
                    "get_width": 2.85,
                    "width_scale": 1,
                    "width_min_pixels": 2,
                    "width_max_pixels": 8,
                    "width_units": "pixels",
                    "cap_rounded": True,
                    "joint_rounded": True,
                    "billboard": False,
                    "opacity": 0.55,
                    "stroked": True,
                },
                "legend": {
                    "title": "Speed (km/h)",
                    "label_column": "speed_bins",
                    "color_column": "speed_bins_colormap",
                    "sort": "ascending",
                    "label_suffix": None,
                },
                "geodataframe": DependsOn("filter_speed_cols"),
            }
            | (params_dict.get("generate_speedmap_layers") or {}),
            method="call",
        ),
        "zoom_speed_gdf_extent": Node(
            async_task=view_state_deck_gdf.validate()
            .set_task_instance_id("zoom_speed_gdf_extent")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "pitch": 0,
                "bearing": 0,
                "gdf": DependsOn("filter_speed_cols"),
            }
            | (params_dict.get("zoom_speed_gdf_extent") or {}),
            method="call",
        ),
        "draw_speedmap": Node(
            async_task=draw_map.validate()
            .set_task_instance_id("draw_speedmap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "static": False,
                "title": None,
                "max_zoom": 10,
                "legend_style": {
                    "placement": "bottom-right",
                },
                "geo_layers": DependsOn("generate_speedmap_layers"),
                "view_state": DependsOn("zoom_speed_gdf_extent"),
            }
            | (params_dict.get("draw_speedmap") or {}),
            method="call",
        ),
        "persist_speedmap_html": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("persist_speedmap_html")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename_suffix": "speedmap",
                "text": DependsOn("draw_speedmap"),
            }
            | (params_dict.get("persist_speedmap_html") or {}),
            method="call",
        ),
        "get_sitrep_config": Node(
            async_task=get_sitrep_event_config.validate()
            .set_task_instance_id("get_sitrep_config")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "region_column": "region",
            }
            | (params_dict.get("get_sitrep_config") or {}),
            method="call",
        ),
        "generate_sitrep_df": Node(
            async_task=compile_sitrep.validate()
            .set_task_instance_id("generate_sitrep_df")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "er_io": DependsOn("er_client_name"),
                "event_details": DependsOn("get_sitrep_config"),
                "time_range": DependsOn("time_range"),
            }
            | (params_dict.get("generate_sitrep_df") or {}),
            method="call",
        ),
        "persist_livestock_events_gpkg": Node(
            async_task=persist_df.validate()
            .set_task_instance_id("persist_livestock_events_gpkg")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filetype": "csv",
                "filename": "sitrep_report",
                "df": DependsOn("generate_sitrep_df"),
            }
            | (params_dict.get("persist_livestock_events_gpkg") or {}),
            method="call",
        ),
        "vehicle_patrols": Node(
            async_task=get_patrol_observations.validate()
            .set_task_instance_id("vehicle_patrols")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "client": DependsOn("er_client_name"),
                "time_range": DependsOn("time_range"),
                "include_patrol_details": True,
                "raise_on_empty": True,
                "sub_page_size": 100,
                "patrol_types": [
                    "MEP_routine_vehicle_patrol_bravo_team",
                    "MEP_routine_vehicle_patrol_foxtrot_team",
                    "MEP_Routine_Vehicle_Patrol - Mwaluganje Team",
                    "MEP_routine_vehicle_patrol_hq_team",
                    "MEP_routine_vehicle_patrol_delta_team",
                    "MEP_routine_vehicle_patrol_echo_team",
                    "MEP_routine_vehicle_patrol_kilo_team",
                    "MEP_routine_vehicle_patrol_mobile_team",
                    "MEP_routine_vehicle_patrol_alpha_team",
                    "MEP_routine_vehicle_patrol_charlie_team",
                    "MEP_routine_vehicle_patrol_golf_team",
                ],
            }
            | (params_dict.get("vehicle_patrols") or {}),
            method="call",
        ),
        "vehicle_patrol_reloc": Node(
            async_task=process_relocations.validate()
            .set_task_instance_id("vehicle_patrol_reloc")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "observations": DependsOn("vehicle_patrols"),
                "relocs_columns": [
                    "patrol_id",
                    "patrol_start_time",
                    "patrol_end_time",
                    "geometry",
                    "patrol_type__value",
                    "patrol_type__display",
                    "patrol_serial_number",
                    "patrol_status",
                    "patrol_subject",
                    "groupby_col",
                    "fixtime",
                    "junk_status",
                    "extra__source",
                ],
                "filter_point_coords": [
                    {
                        "x": 180.0,
                        "y": 90.0,
                    },
                    {
                        "x": 0.0,
                        "y": 0.0,
                    },
                    {
                        "x": 1.0,
                        "y": 1.0,
                    },
                ],
            }
            | (params_dict.get("vehicle_patrol_reloc") or {}),
            method="call",
        ),
        "vehicle_patrol_traj": Node(
            async_task=relocations_to_trajectory.validate()
            .set_task_instance_id("vehicle_patrol_traj")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "relocations": DependsOn("vehicle_patrol_reloc"),
                "trajectory_segment_filter": {
                    "min_length_meters": 0.35,
                    "max_length_meters": 5000.0,
                    "max_time_secs": 18000.0,
                    "min_time_secs": 1.0,
                    "max_speed_kmhr": 100.0,
                    "min_speed_kmhr": 10.0,
                },
            }
            | (params_dict.get("vehicle_patrol_traj") or {}),
            method="call",
        ),
        "persist_vehicle_traj": Node(
            async_task=persist_df.validate()
            .set_task_instance_id("persist_vehicle_traj")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("vehicle_patrol_traj"),
                "filetype": "geoparquet",
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename": "vehicle_patrol_trajectories",
            }
            | (params_dict.get("persist_vehicle_traj") or {}),
            method="call",
        ),
        "vehicle_traj_colormap": Node(
            async_task=apply_color_map.validate()
            .set_task_instance_id("vehicle_traj_colormap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("vehicle_patrol_traj"),
                "colormap": "viridis",
                "input_column_name": "extra__patrol_type__value",
                "output_column_name": "patrol_type_colormap",
            }
            | (params_dict.get("vehicle_traj_colormap") or {}),
            method="call",
        ),
        "vehicle_zoom_value": Node(
            async_task=view_state_deck_gdf.validate()
            .set_task_instance_id("vehicle_zoom_value")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "pitch": 0,
                "bearing": 0,
                "gdf": DependsOn("vehicle_traj_colormap"),
            }
            | (params_dict.get("vehicle_zoom_value") or {}),
            method="call",
        ),
        "vehicle_patrol_path_layer": Node(
            async_task=create_path_layer.validate()
            .set_task_instance_id("vehicle_patrol_path_layer")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "get_color": "patrol_type_colormap",
                    "get_width": 2.85,
                    "width_scale": 1,
                    "width_min_pixels": 2,
                    "width_max_pixels": 8,
                    "width_units": "pixels",
                    "cap_rounded": True,
                    "joint_rounded": True,
                    "billboard": False,
                    "opacity": 0.55,
                    "stroked": True,
                },
                "legend": {
                    "title": "Patrol team",
                    "label_column": "extra__patrol_type__value",
                    "color_column": "patrol_type_colormap",
                    "sort": "ascending",
                    "label_suffix": None,
                },
                "geodataframe": DependsOn("vehicle_traj_colormap"),
            }
            | (params_dict.get("vehicle_patrol_path_layer") or {}),
            method="call",
        ),
        "draw_vehicles_map": Node(
            async_task=draw_map.validate()
            .set_task_instance_id("draw_vehicles_map")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "static": False,
                "title": None,
                "max_zoom": 10,
                "legend_style": {
                    "placement": "bottom-right",
                },
                "geo_layers": DependsOn("vehicle_patrol_path_layer"),
                "view_state": DependsOn("vehicle_zoom_value"),
            }
            | (params_dict.get("draw_vehicles_map") or {}),
            method="call",
        ),
        "vehicle_patrol_map": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("vehicle_patrol_map")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename": "vehicle_patrols_map.html",
                "text": DependsOn("draw_vehicles_map"),
            }
            | (params_dict.get("vehicle_patrol_map") or {}),
            method="call",
        ),
        "foot_patrols": Node(
            async_task=get_patrol_observations.validate()
            .set_task_instance_id("foot_patrols")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "client": DependsOn("er_client_name"),
                "time_range": DependsOn("time_range"),
                "include_patrol_details": True,
                "raise_on_empty": True,
                "sub_page_size": 100,
                "patrol_types": [
                    "MEP_routine_foot_patrol_bravo_team",
                    "MEP_routine_foot_patrol_foxtrot_team",
                    "MEP_routine_foot_patrol_HQ_team",
                    "MEP_routine_foot_patrol_ Delta_Team",
                    "MEP_routine_foot_patrol_echo_team",
                    "MEP_routine_foot_patrol_kilo_team",
                    "mwaluganje_routine_foot_patrol_alpha_team",
                    "MEP_routine_foot_patrol_alpha_team",
                    "MEP_routine_foot_patrol_charlie_team",
                    "MEP_routine_foot_patrol_golf_team",
                    "MEP_routine_foot_patrol_marmanet",
                ],
            }
            | (params_dict.get("foot_patrols") or {}),
            method="call",
        ),
        "foot_patrol_reloc": Node(
            async_task=process_relocations.validate()
            .set_task_instance_id("foot_patrol_reloc")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "observations": DependsOn("foot_patrols"),
                "relocs_columns": [
                    "patrol_id",
                    "patrol_start_time",
                    "patrol_end_time",
                    "geometry",
                    "patrol_type__value",
                    "patrol_type__display",
                    "patrol_serial_number",
                    "patrol_status",
                    "patrol_subject",
                    "groupby_col",
                    "fixtime",
                    "junk_status",
                    "extra__source",
                ],
                "filter_point_coords": [
                    {
                        "x": 180.0,
                        "y": 90.0,
                    },
                    {
                        "x": 0.0,
                        "y": 0.0,
                    },
                    {
                        "x": 1.0,
                        "y": 1.0,
                    },
                ],
            }
            | (params_dict.get("foot_patrol_reloc") or {}),
            method="call",
        ),
        "foot_patrol_traj": Node(
            async_task=relocations_to_trajectory.validate()
            .set_task_instance_id("foot_patrol_traj")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "relocations": DependsOn("foot_patrol_reloc"),
                "trajectory_segment_filter": {
                    "min_length_meters": 0.001,
                    "max_length_meters": 5000.0,
                    "max_time_secs": 14400.0,
                    "min_time_secs": 1.0,
                    "max_speed_kmhr": 9.0,
                    "min_speed_kmhr": 0.5,
                },
            }
            | (params_dict.get("foot_patrol_traj") or {}),
            method="call",
        ),
        "persist_foot_traj": Node(
            async_task=persist_df.validate()
            .set_task_instance_id("persist_foot_traj")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("foot_patrol_traj"),
                "filetype": "geoparquet",
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename": "foot_patrol_trajectories",
            }
            | (params_dict.get("persist_foot_traj") or {}),
            method="call",
        ),
        "foot_traj_colormap": Node(
            async_task=apply_color_map.validate()
            .set_task_instance_id("foot_traj_colormap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("foot_patrol_traj"),
                "colormap": "viridis",
                "input_column_name": "extra__patrol_type__value",
                "output_column_name": "patrol_type_colormap",
            }
            | (params_dict.get("foot_traj_colormap") or {}),
            method="call",
        ),
        "foot_zoom_value": Node(
            async_task=view_state_deck_gdf.validate()
            .set_task_instance_id("foot_zoom_value")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "pitch": 0,
                "bearing": 0,
                "gdf": DependsOn("foot_traj_colormap"),
            }
            | (params_dict.get("foot_zoom_value") or {}),
            method="call",
        ),
        "foot_patrol_path_layer": Node(
            async_task=create_path_layer.validate()
            .set_task_instance_id("foot_patrol_path_layer")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "get_color": "patrol_type_colormap",
                    "get_width": 2.85,
                    "width_scale": 1,
                    "width_min_pixels": 2,
                    "width_max_pixels": 8,
                    "width_units": "pixels",
                    "cap_rounded": True,
                    "joint_rounded": True,
                    "billboard": False,
                    "opacity": 0.55,
                    "stroked": True,
                },
                "legend": {
                    "title": "Patrol team",
                    "label_column": "extra__patrol_type__value",
                    "color_column": "patrol_type_colormap",
                    "sort": "ascending",
                    "label_suffix": None,
                },
                "geodataframe": DependsOn("foot_traj_colormap"),
            }
            | (params_dict.get("foot_patrol_path_layer") or {}),
            method="call",
        ),
        "draw_foot_map": Node(
            async_task=draw_map.validate()
            .set_task_instance_id("draw_foot_map")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "static": False,
                "title": None,
                "max_zoom": 10,
                "legend_style": {
                    "placement": "bottom-right",
                },
                "geo_layers": DependsOn("foot_patrol_path_layer"),
                "view_state": DependsOn("foot_zoom_value"),
            }
            | (params_dict.get("draw_foot_map") or {}),
            method="call",
        ),
        "foot_patrol_map": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("foot_patrol_map")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename": "foot_patrols_map.html",
                "text": DependsOn("draw_foot_map"),
            }
            | (params_dict.get("foot_patrol_map") or {}),
            method="call",
        ),
        "download_roi_file": Node(
            async_task=fetch_and_persist_file.validate()
            .set_task_instance_id("download_roi_file")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "url": "https://www.dropbox.com/scl/fi/2bpktq45zns9igryl6q9l/ROIs.gpkg?rlkey=sojch2njmvsa3i5a3f3pt11xq&st=9x70z6z1&dl=0",
                "output_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "overwrite_existing": False,
                "retries": 3,
                "unzip": False,
            }
            | (params_dict.get("download_roi_file") or {}),
            method="call",
        ),
        "load_roi": Node(
            async_task=load_df.validate()
            .set_task_instance_id("load_roi")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "file_path": DependsOn("download_roi_file"),
                "layer": None,
                "deserialize_json": False,
            }
            | (params_dict.get("load_roi") or {}),
            method="call",
        ),
        "transform_roi": Node(
            async_task=transform_gdf_crs.validate()
            .set_task_instance_id("transform_roi")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("load_roi"),
                "crs": "EPSG:4326",
            }
            | (params_dict.get("transform_roi") or {}),
            method="call",
        ),
        "process_ndvi_charts": Node(
            async_task=process_aoi_ndvi_charts.validate()
            .set_task_instance_id("process_ndvi_charts")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("transform_roi"),
                "er_client": DependsOn("gee_project_name"),
                "aoi_column": "name",
                "time_range": DependsOn("time_range"),
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("process_ndvi_charts") or {}),
            method="call",
        ),
        "convert_sightings_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_sightings_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "html_path": DependsOn("persist_sightings_urls"),
                "config": {
                    "full_page": False,
                    "device_scale_factor": 2.0,
                    "wait_for_timeout": 40000,
                    "max_concurrent_pages": 1,
                },
            }
            | (params_dict.get("convert_sightings_png") or {}),
            method="call",
        ),
        "convert_speedmap_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_speedmap_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "html_path": DependsOn("persist_speedmap_html"),
                "config": {
                    "full_page": False,
                    "device_scale_factor": 2.0,
                    "wait_for_timeout": 40000,
                    "max_concurrent_pages": 1,
                },
            }
            | (params_dict.get("convert_speedmap_png") or {}),
            method="call",
        ),
        "convert_vehicle_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_vehicle_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "html_path": DependsOn("vehicle_patrol_map"),
                "config": {
                    "full_page": False,
                    "device_scale_factor": 2.0,
                    "wait_for_timeout": 40000,
                    "max_concurrent_pages": 1,
                },
            }
            | (params_dict.get("convert_vehicle_png") or {}),
            method="call",
        ),
        "convert_foot_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_foot_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "html_path": DependsOn("foot_patrol_map"),
                "config": {
                    "full_page": False,
                    "device_scale_factor": 2.0,
                    "wait_for_timeout": 40000,
                    "max_concurrent_pages": 1,
                },
            }
            | (params_dict.get("convert_foot_png") or {}),
            method="call",
        ),
        "convert_ndvi_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_ndvi_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "html_path": DependsOn("process_ndvi_charts"),
                "config": {
                    "full_page": False,
                    "device_scale_factor": 2.0,
                    "wait_for_timeout": 10,
                    "max_concurrent_pages": 1,
                },
            }
            | (params_dict.get("convert_ndvi_png") or {}),
            method="call",
        ),
        "convert_collared_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_collared_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "html_path": DependsOn("process_subject_charts"),
                "config": {
                    "full_page": False,
                    "device_scale_factor": 2.0,
                    "wait_for_timeout": 10,
                    "max_concurrent_pages": 1,
                },
            }
            | (params_dict.get("convert_collared_png") or {}),
            method="call",
        ),
        "mep_monthly_dashboard": Node(
            async_task=gather_dashboard.validate()
            .set_task_instance_id("mep_monthly_dashboard")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "details": DependsOn("workflow_details"),
                "time_range": DependsOn("time_range"),
                "groupers": DependsOn("groupers"),
            }
            | (params_dict.get("mep_monthly_dashboard") or {}),
            method="call",
        ),
    }
    graph = Graph(dependencies=dependencies, nodes=nodes)
    results = graph.execute()
    return results
