# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details

# ruff: noqa: E402

"""WARNING: This file is generated in a testing context and should not be used in production.
Lines specific to the testing context are marked with a test tube emoji (ðŸ§ª) to indicate
that they would not be included (or would be different) in the production version of this file.
"""

import json
import os
import warnings  # ðŸ§ª


from ecoscope_workflows_core.graph import DependsOn, DependsOnSequence, Graph, Node

from ecoscope_workflows_core.tasks.filter import set_time_range
from ecoscope_workflows_ext_custom.tasks import gather_doc
from ecoscope_workflows_core.tasks.results import gather_output_files

from ..params import Params


def main(params: Params):
    warnings.warn("This test script should not be used in production!")  # ðŸ§ª

    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    dependencies = {
        "time_range": [],
        "monthly_report": ["time_range"],
        "output_files": ["monthly_report", "monthly_report"],
    }

    nodes = {
        "time_range": Node(
            async_task=set_time_range.validate()
            .handle_errors(task_instance_id="time_range")
            .set_executor("lithops"),
            partial={
                "time_format": "%d %b %Y %H:%M:%S %Z",
            }
            | (params_dict.get("time_range") or {}),
            method="call",
        ),
        "monthly_report": Node(
            async_task=gather_doc.validate()
            .handle_errors(task_instance_id="monthly_report")
            .set_executor("lithops"),
            partial={
                "title": "MEP Monthly Report",
                "time_range": DependsOn("time_range"),
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename": "mep_monthly_report",
                "doc_widgets": [],
            }
            | (params_dict.get("monthly_report") or {}),
            method="call",
        ),
        "output_files": Node(
            async_task=gather_output_files.validate()
            .handle_errors(task_instance_id="output_files")
            .set_executor("lithops"),
            partial={
                "files": DependsOnSequence(
                    [
                        DependsOn("monthly_report"),
                        DependsOn("monthly_report"),
                    ],
                ),
            }
            | (params_dict.get("output_files") or {}),
            method="call",
        ),
    }
    graph = Graph(dependencies=dependencies, nodes=nodes)
    results = graph.execute()
    return results
