# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details


import json
import os
import sys
from io import TextIOWrapper

import click
import obstore
import pydantic
import ruamel.yaml

from .dispatch import dispatch
from .formdata import FormData
from .metadata import (
    formdata_to_params,
    get_data_connection_property_names,
    get_rjsf,
    params_to_formdata,
)
from .params import Params


@click.group()
def cli() -> None:
    pass


@cli.command()
@click.option(
    "--config-file",
    type=click.File("r"),
    required=True,
    help="Configuration parameters for running the workflow.",
)
@click.option(
    "--execution-mode",
    required=True,
    type=click.Choice(["async", "sequential"]),
)
@click.option(
    "--mock-io/--no-mock-io",
    is_flag=True,
    default=False,
    help="Whether or not to mock io with 3rd party services; for testing only.",
)
def run(
    config_file: TextIOWrapper,
    execution_mode: str,
    mock_io: bool,
) -> None:
    results_url = os.environ.get("ECOSCOPE_WORKFLOWS_RESULTS")
    if not results_url:
        raise ValueError("Environment variable ECOSCOPE_WORKFLOWS_RESULTS is required.")
    yaml = ruamel.yaml.YAML(typ="safe")
    params = Params(**yaml.load(config_file))
    response = dispatch(execution_mode, mock_io, params)
    result_store = obstore.store.from_url(results_url)
    result_bytes = response.model_dump_json().encode("utf-8")
    put_result = result_store.put("result.json", result_bytes)
    if not put_result:
        raise RuntimeError("Failed to put result json in result store.")


@cli.command()
@click.argument(
    "metadata_attribute",
    type=click.Choice(["rjsf", "data-connection-property-names"]),
    required=True,
)
def get(metadata_attribute: str) -> None:
    """Get the metadata for the workflow."""
    getter = {
        "rjsf": get_rjsf,
        "data-connection-property-names": get_data_connection_property_names,
    }.get(metadata_attribute)
    if getter is None:
        raise ValueError(f"Unknown metadata attribute: {metadata_attribute}")
    result = getter()
    as_json = json.dumps(result)
    print(as_json)


@cli.command()
@click.option(
    "--from",
    "from_",
    required=True,
    type=click.Choice(["params", "formdata"]),
)
@click.option(
    "--to",
    required=True,
    type=click.Choice(["params", "formdata"]),
)
@click.option(
    "--json",
    "json_",
    required=True,
    type=click.File("r"),
    default=sys.stdin,
)
def convert(
    from_: str,
    to: str,
    json_: TextIOWrapper,
) -> None:
    """Get the metadata for the workflow."""
    json_txt = json_.read()
    try:
        loaded = json.loads(json_txt)
    except json.JSONDecodeError as e:
        raise ValueError(f"Failed to parse JSON string: {json_txt}") from e
    try:
        match from_, to:
            case ("params", "formdata"):
                result = params_to_formdata(loaded)
                as_json = json.dumps(result)
            case ("formdata", "params"):
                formdata = FormData(**loaded)
                result = formdata_to_params(formdata)
                as_json = result.model_dump_json()
            case _:
                raise ValueError(f"Unknown conversion: {from_} -> {to}")
    except pydantic.ValidationError as e:
        as_json = e.json(include_url=True)

    print(as_json)


if __name__ == "__main__":
    cli()
